<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LandApp → Mapbox (Phase 1 colours)</title>

  <link href="https://api.mapbox.com/mapbox-gl-js/v3.7.0/mapbox-gl.css" rel="stylesheet">
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.7.0/mapbox-gl.js"></script>

  <!-- Reprojection -->
  <script src="https://cdn.jsdelivr.net/npm/proj4@2.11.0/dist/proj4.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }

    .panel {
      position: absolute;
      top: 12px; left: 12px;
      background: rgba(255,255,255,0.95);
      padding: 10px 12px;
      border-radius: 10px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.14);
      font: 13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      max-width: 360px;
      z-index: 2;
    }
    .panel h3 { margin: 0 0 6px; font-size: 14px; }
    .meta { color: #444; margin-bottom: 8px; }

    .legend { max-height: 55vh; overflow: auto; padding-right: 6px; }
    .legend .row { display: flex; gap: 8px; align-items: flex-start; margin: 6px 0; }
    .legend .swatch {
      width: 14px; height: 14px; border: 1px solid rgba(0,0,0,0.25);
      border-radius: 3px; margin-top: 2px; flex: 0 0 auto;
    }
    .legend .code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px; min-width: 64px; white-space: nowrap;
    }
    .legend .habitat { font-size: 12px; opacity: 0.9; }
  </style>
</head>

<body>
  <div id="map"></div>

  <div class="panel">
    <h3 id="title">LandApp habitats</h3>
    <div class="meta" id="subtitle">Loading…</div>
    <div class="legend" id="legend"></div>
  </div>

  <script type="module">
    import {
      PHASE1_COLORS,
      P1_CODE_KEY,
      P1_HABITAT_KEY,
      buildPhase1FillExpression,
      hashColor
    } from "./phase1-style.js";

    // ✅ Put your *public* Mapbox token here (restrict by URL in Mapbox dashboard)
    mapboxgl.accessToken = "pk.eyJ1IjoicG9udGMiLCJhIjoiY2tzaXB5ZWFtMjEyazJucDJqMXhjODh2ciJ9.TZQLYloF5lqmchrq4JilHQ";


    const map = new mapboxgl.Map({
      container: "map",
      style: "mapbox://styles/mapbox/outdoors-v12",
      center: [-2.93, 54.55],
      zoom: 12
    });
    map.addControl(new mapboxgl.NavigationControl(), "top-right");

    // EPSG:27700 (OSGB36 / British National Grid)
    proj4.defs("EPSG:27700",
      "+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 " +
      "+x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs"
    );

    function reprojectCoord([e, n]) {
      const [lon, lat] = proj4("EPSG:27700", "WGS84", [e, n]);
      return [lon, lat];
    }

    function reprojectGeometry(geom) {
      const t = geom.type;
      const c = geom.coordinates;

      if (t === "Point") return { ...geom, coordinates: reprojectCoord(c) };
      if (t === "MultiPoint") return { ...geom, coordinates: c.map(reprojectCoord) };
      if (t === "LineString") return { ...geom, coordinates: c.map(reprojectCoord) };
      if (t === "MultiLineString") return { ...geom, coordinates: c.map(line => line.map(reprojectCoord)) };
      if (t === "Polygon") return { ...geom, coordinates: c.map(ring => ring.map(reprojectCoord)) };
      if (t === "MultiPolygon") return { ...geom, coordinates: c.map(poly => poly.map(ring => ring.map(reprojectCoord))) };

      throw new Error("Unsupported geometry type: " + t);
    }

    function reprojectFeatureCollection(fc) {
      return {
        ...fc,
        features: fc.features.map(f => ({ ...f, geometry: reprojectGeometry(f.geometry) }))
      };
    }

    function boundsFromGeoJSON(fc) {
      const b = new mapboxgl.LngLatBounds();
      const extend = (xy) => b.extend(xy);

      const walk = (geom) => {
        const t = geom.type;
        const c = geom.coordinates;
        if (t === "Point") extend(c);
        else if (t === "MultiPoint") c.forEach(extend);
        else if (t === "LineString") c.forEach(extend);
        else if (t === "MultiLineString") c.flat().forEach(extend);
        else if (t === "Polygon") c.flat().forEach(extend);
        else if (t === "MultiPolygon") c.flat(2).forEach(extend);
      };

      fc.features.forEach(f => walk(f.geometry));
      return b;
    }

    function escapeHtml(s) {
      return String(s ?? "")
        .replaceAll("&","&amp;").replaceAll("<","&lt;")
        .replaceAll(">","&gt;").replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function renderLegend(items) {
      const el = document.getElementById("legend");
      el.innerHTML = items.map(({ code, habitat, color }) => `
        <div class="row">
          <span class="swatch" style="background:${escapeHtml(color)}"></span>
          <span class="code">${escapeHtml(code)}</span>
          <span class="habitat">${escapeHtml(habitat || "")}</span>
        </div>
      `).join("");
    }

    async function loadAllLayers() {
      const manifestResp = await fetch("./data/layers.json");
      if (!manifestResp.ok) throw new Error("Failed to load ./data/layers.json");
      const { layers } = await manifestResp.json();

      // Fetch + reproject all files in parallel
      const loaded = await Promise.all(layers.map(async (layer) => {
        const resp = await fetch(layer.url);
        if (!resp.ok) throw new Error(`Failed to load ${layer.url}`);
        const fc27700 = await resp.json();
        const fcWgs84 = reprojectFeatureCollection(fc27700);

        // Normalise properties + attach layer metadata
        fcWgs84.features = fcWgs84.features.map(f => {
          const props = { ...(f.properties || {}) };

          if (props[P1_CODE_KEY]) {
            props[P1_CODE_KEY] = String(props[P1_CODE_KEY]).trim().toUpperCase();
          }
          if (props[P1_HABITAT_KEY]) {
            props[P1_HABITAT_KEY] = String(props[P1_HABITAT_KEY]).trim();
          }

          props._layer_id = layer.id;
          props._layer_name = layer.name;

          return { ...f, properties: props };
        });

        return { layer, fcWgs84 };
      }));

      // Build code->habitat map across ALL files for legend
      const codeToHabitat = new Map();
      for (const { fcWgs84 } of loaded) {
        for (const f of fcWgs84.features) {
          const p = f.properties || {};
          const code = (p[P1_CODE_KEY] ?? "").toString().trim().toUpperCase();
          if (!code) continue;
          if (!codeToHabitat.has(code)) {
            codeToHabitat.set(code, (p[P1_HABITAT_KEY] ?? "").toString().trim());
          }
        }
      }

      const allCodes = Array.from(codeToHabitat.keys()).sort((a,b)=>a.localeCompare(b,"en"));
      const fillExpr = buildPhase1FillExpression(allCodes);

      document.getElementById("subtitle").textContent =
        `Loaded ${layers.length} files — coloured by Phase 1 p1 code`;

      renderLegend(allCodes.map(code => ({
        code,
        habitat: codeToHabitat.get(code),
        color: PHASE1_COLORS?.[code] ?? hashColor(code)
      })));

      // Add each file as a source + fill/line layers
      for (const { layer, fcWgs84 } of loaded) {
        const sourceId = `src-${layer.id}`;
        map.addSource(sourceId, { type: "geojson", data: fcWgs84 });

        map.addLayer({
          id: `fill-${layer.id}`,
          type: "fill",
          source: sourceId,
          filter: ["==", ["geometry-type"], "Polygon"],
          paint: {
            "fill-color": fillExpr,
            "fill-opacity": 0.55
          }
        });

        map.addLayer({
          id: `line-${layer.id}`,
          type: "line",
          source: sourceId,
          filter: ["==", ["geometry-type"], "Polygon"],
          paint: {
            "line-width": 1.2,
            "line-color": "#2b2b2b"
          }
        });
      }

      // Fit to combined bounds
      const combined = new mapboxgl.LngLatBounds();
      for (const { fcWgs84 } of loaded) {
        const b = boundsFromGeoJSON(fcWgs84);
        if (!b.isEmpty()) combined.extend(b.getSouthWest()).extend(b.getNorthEast());
      }
      if (!combined.isEmpty()) map.fitBounds(combined, { padding: 40 });

      // One popup handler for all fills
      const fillLayerIds = layers.map(l => `fill-${l.id}`);

      map.on("click", (e) => {
        const f = map.queryRenderedFeatures(e.point, { layers: fillLayerIds })[0];
        if (!f) return;

        const p = f.properties || {};
        new mapboxgl.Popup({ maxWidth: "520px" })
          .setLngLat(e.lngLat)
          .setHTML(`
            <div style="font:13px system-ui">
              <div><b>p1 code:</b> <span style="font-family:ui-monospace">${escapeHtml(p[P1_CODE_KEY])}</span></div>
              <div><b>p1 habitat:</b> ${escapeHtml(p[P1_HABITAT_KEY])}</div>
              <div><b>survey:</b> ${escapeHtml(p["survey name"])} (${escapeHtml(p["survey code"])})</div>
              <div><b>file:</b> ${escapeHtml(p["_layer_name"] || p["_layer_id"])}</div>
            </div>
          `)
          .addTo(map);
      });

      map.on("mousemove", (e) => {
        const f = map.queryRenderedFeatures(e.point, { layers: fillLayerIds })[0];
        map.getCanvas().style.cursor = f ? "pointer" : "";
      });
    }

    map.on("load", () => loadAllLayers().catch(err => {
      console.error(err);
      alert(err.message);
    }));
  </script>
</body>
</html>
